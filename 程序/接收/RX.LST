C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE RX
OBJECT MODULE PLACED IN RX.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE RX.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include "12864.h"
   4          #include "ds1302.h"
   5          
   6          
   7          uint stwdh=35;       //温度上限
   8          uint stwdl=6;        //温度下限
   9          
  10          uint stsdh=85;       //湿度上限
  11          uint stsdl=20;       //湿度下限
  12          sbit  fmq  =P1^7;      //蜂鸣器
  13          
  14          #define TX_ADR_WIDTH    5     // 5 uints TX address width
  15          #define RX_ADR_WIDTH    5     // 5 uints RX address width
  16          #define TX_PLOAD_WIDTH  32    // 20 uints TX payload
  17          #define RX_PLOAD_WIDTH  32    // 20 uints TX payload
  18          uint const TX_ADDRESS[TX_ADR_WIDTH]= {0x34,0x43,0x10,0x10,0x01};  //本地地址
  19          uint const RX_ADDRESS[RX_ADR_WIDTH]= {0x34,0x43,0x10,0x10,0x01};  //接收地址
  20          //***************************************NRF24L01寄存器指令***********************************************
             -********
  21          #define READ_REG        0x00     // 读寄存器指令
  22          #define WRITE_REG       0x20  // 写寄存器指令
  23          #define RD_RX_PLOAD     0x61     // 读取接收数据指令
  24          #define WR_TX_PLOAD     0xA0     // 写待发数据指令
  25          #define FLUSH_TX        0xE1  // 冲洗发送 FIFO指令
  26          #define FLUSH_RX        0xE2     // 冲洗接收 FIFO指令
  27          #define REUSE_TX_PL     0xE3     // 定义重复装载数据指令
  28          #define NOP             0xFF     // 保留
  29          //*************************************SPI(nRF24L01)寄存器地址********************************************
             -********
  30          #define CONFIG          0x00  // 配置收发状态，CRC校验模式以及收发状态响应方式
  31          #define EN_AA           0x01  // 自动应答功能设置
  32          #define EN_RXADDR       0x02  // 可用信道设置
  33          #define SETUP_AW        0x03  // 收发地址宽度设置
  34          #define SETUP_RETR      0x04  // 自动重发功能设置
  35          #define RF_CH           0x05  // 工作频率设置
  36          #define RF_SETUP        0x06  // 发射速率、功耗功能设置
  37          #define STATUS          0x07  // 状态寄存器
  38          #define OBSERVE_TX      0x08  // 发送监测功能
  39          #define CD              0x09  // 地址检测           
  40          #define RX_ADDR_P0      0x0A  // 频道0接收数据地址
  41          #define RX_ADDR_P1      0x0B  // 频道1接收数据地址
  42          #define RX_ADDR_P2      0x0C  // 频道2接收数据地址
  43          #define RX_ADDR_P3      0x0D  // 频道3接收数据地址
  44          #define RX_ADDR_P4      0x0E  // 频道4接收数据地址
  45          #define RX_ADDR_P5      0x0F  // 频道5接收数据地址
  46          #define TX_ADDR         0x10  // 发送地址寄存器
  47          #define RX_PW_P0        0x11  // 接收频道0接收数据长度
  48          #define RX_PW_P1        0x12  // 接收频道0接收数据长度
  49          #define RX_PW_P2        0x13  // 接收频道0接收数据长度
  50          #define RX_PW_P3        0x14  // 接收频道0接收数据长度
  51          #define RX_PW_P4        0x15  // 接收频道0接收数据长度
  52          #define RX_PW_P5        0x16  // 接收频道0接收数据长度
  53          #define FIFO_STATUS     0x17  // FIFO栈入栈出状态寄存器设置
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 2   

  54          //**************************************************************************************
  55          
  56          
  57          uint wendu=0;
  58          uint shidu=0;
  59          unsigned int idata pm25=0;
  60          unsigned char  idata RxBuf[32];
  61          unsigned int flag=0;
  62          uchar  hor,min,sec,SetA=0,SetB=0; 
  63          unsigned char year=17,month=2,date=11;
  64          unsigned int Alpm25=200;
  65          uchar  initial_time[]={0x00,0x00,0x00};
  66          unsigned int guangzhao=0;
  67          
  68          //****************************************IO端口定义***************************************
  69          sbit  MISO  =P0^2;
  70          sbit  MOSI  =P0^4;
  71          sbit  SCK   =P0^1;
  72          sbit  CE    =P0^0;
  73          sbit  CSN   =P0^3;
  74          sbit  IRQ   =P0^5;
  75          
  76          
  77          sbit    k1  =P2^0;
  78          sbit    k2  =P2^1;
  79          sbit    k3  =P2^2;
  80          sbit    k4  =P2^3;
  81          sbit    k5  =P2^4;
  82          
  83          void Delay(unsigned int s);
  84          void inerDelay_us(unsigned char n);
  85          void init_NRF24L01(void);
  86          uint SPI_RW(uint uchar);
  87          uchar SPI_Read(uchar reg);
  88          void SetRX_Mode(void);
  89          uint SPI_RW_Reg(uchar reg, uchar value);
  90          uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars);
  91          uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars);
  92          unsigned char nRF24L01_RxPacket(unsigned char* rx_buf);
  93          void nRF24L01_TxPacket(unsigned char * tx_buf);
  94          
  95          void delay_ms(unsigned int z)
  96          { 
  97   1         uint x,y;
  98   1         for(x=z;x>0;x--)
  99   1         for(y=110;y>0;y--);
 100   1      }
 101          //*****************************************长延时*****************************************
 102          void Delay(unsigned int s)
 103          {
 104   1         unsigned int i;
 105   1         for(i=0; i<s; i++);
 106   1         for(i=0; i<s; i++);
 107   1      }
 108          //******************************************************************************************
 109          uint  bdata sta;   //状态标志
 110          sbit  RX_DR =sta^6;
 111          sbit  TX_DS =sta^5;
 112          sbit  MAX_RT   =sta^4;
 113          /******************************************************************************************
 114          /*延时函数
 115          /******************************************************************************************/
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 3   

 116          void inerDelay_us(unsigned char n)
 117          {
 118   1         for(;n>0;n--)  _nop_();
 119   1      }
 120          //****************************************************************************************
 121          /*NRF24L01初始化
 122          //***************************************************************************************/
 123          void init_NRF24L01(void)
 124          {
 125   1         inerDelay_us(100);
 126   1         CE=0;    // chip enable
 127   1         CSN=1;   // Spi disable 
 128   1         SCK=0;   // Spi clock line init high
 129   1         SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // 写本地地址   
 130   1         SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // 写接收端地址
 131   1         SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      //  频道0自动  ACK应答允许 
 132   1         SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  //  允许接收地址只有频道0，如果需要多频道可以参考Page21  
 133   1         SPI_RW_Reg(WRITE_REG + RF_CH, 0);        //   设置信道工作为2.4GHZ，收发必须一致
 134   1         SPI_RW_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH); //设置接收数据长度，本次设置为32字节
 135   1         SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);         //设置发射速率为1MHZ，发射功率为最大值0dB
 136   1         SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);        // IRQ收发完成中断响应，16位CRC  ，主接收
 137   1      }
 138          /****************************************************************************************************
 139          /*函数：uint SPI_RW(uint uchar)
 140          /*功能：NRF24L01的SPI写时序
 141          /****************************************************************************************************/
 142          uint SPI_RW(uint uchar)
 143          {
 144   1         uint bit_ctr;
 145   1         for(bit_ctr=0;bit_ctr<8;bit_ctr++) // output 8-bit
 146   1         {
 147   2            MOSI = (uchar & 0x80);         // output 'uchar', MSB to MOSI
 148   2            uchar = (uchar << 1);           // shift next bit into MSB..
 149   2            SCK = 1;                      // Set SCK high..
 150   2            uchar |= MISO;               // capture current MISO bit
 151   2            SCK = 0;                  // ..then set SCK low again
 152   2         }
 153   1         return(uchar);                  // return read uchar
 154   1      }
 155          /****************************************************************************************************
 156          /*函数：uchar SPI_Read(uchar reg)
 157          /*功能：NRF24L01的SPI时序
 158          /****************************************************************************************************/
 159          uchar SPI_Read(uchar reg)
 160          {
 161   1         uchar reg_val;
 162   1         
 163   1         CSN = 0;                // CSN low, initialize SPI communication...
 164   1         SPI_RW(reg);            // Select register to read from..
 165   1         reg_val = SPI_RW(0);    // ..then read registervalue
 166   1         CSN = 1;                // CSN high, terminate SPI communication
 167   1         
 168   1         return(reg_val);        // return register value
 169   1      }
 170          /****************************************************************************************************/
 171          /*功能：NRF24L01读写寄存器函数
 172          /****************************************************************************************************/
 173          uint SPI_RW_Reg(uchar reg, uchar value)
 174          {
 175   1         uint status;
 176   1         
 177   1         CSN = 0;                   // CSN low, init SPI transaction
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 4   

 178   1         status = SPI_RW(reg);      // select register
 179   1         SPI_RW(value);             // ..and write value to it..
 180   1         CSN = 1;                   // CSN high again
 181   1         
 182   1         return(status);            // return nRF24L01 status uchar
 183   1      }
 184          /****************************************************************************************************/
 185          /*函数：uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 186          /*功能: 用于读数据，reg：为寄存器地址，pBuf：为待读出数据地址，uchars：读出数据的个数
 187          /****************************************************************************************************/
 188          uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 189          {
 190   1         uint status,uchar_ctr;
 191   1         
 192   1         CSN = 0;                         // Set CSN low, init SPI tranaction
 193   1         status = SPI_RW(reg);            // Select register to write to and read status uchar
 194   1         
 195   1         for(uchar_ctr=0;uchar_ctr<uchars;uchar_ctr++)
 196   1            pBuf[uchar_ctr] = SPI_RW(0);    // 
 197   1         
 198   1         CSN = 1;                           
 199   1         
 200   1         return(status);                    // return nRF24L01 status uchar
 201   1      }
 202          /*********************************************************************************************************
 203          /*函数：uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 204          /*功能: 用于写数据：为寄存器地址，pBuf：为待写入数据地址，uchars：写入数据的个数
 205          /*********************************************************************************************************
             -/
 206          uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 207          {
 208   1         uint status,uchar_ctr;
 209   1         
 210   1         CSN = 0;            //SPI使能       
 211   1         status = SPI_RW(reg);   
 212   1         for(uchar_ctr=0; uchar_ctr<uchars; uchar_ctr++) //
 213   1            SPI_RW(*pBuf++);
 214   1         CSN = 1;           //关闭SPI
 215   1         return(status);    // 
 216   1      }
 217          /****************************************************************************************************/
 218          /*函数：void SetRX_Mode(void)
 219          /*功能：数据接收配置 
 220          /****************************************************************************************************/
 221          void SetRX_Mode(void)
 222          {
 223   1         CE=0;
 224   1      // SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);        // IRQ收发完成中断响应，16位CRC  ，主接收
 225   1         CE = 1; 
 226   1         inerDelay_us(130);
 227   1      }
 228          /******************************************************************************************************/
 229          /*函数：unsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 230          /*功能：数据读取后放如rx_buf接收缓冲区中
 231          /******************************************************************************************************/
 232          unsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 233          {
 234   1         unsigned char revale=0;
 235   1         sta=SPI_Read(STATUS);   // 读取状态寄存其来判断数据接收状况
 236   1         if(RX_DR)            // 判断是否接收到数据
 237   1         {
 238   2             CE = 0;          //SPI使能
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 5   

 239   2            SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);// read receive payload from RX_FIFO buffer
 240   2            revale =1;        //读取数据完成标志
 241   2         }
 242   1         SPI_RW_Reg(WRITE_REG+STATUS,sta);   //接收到数据后RX_DR,TX_DS,MAX_PT都置高为1，通过写1来清楚中断标志
 243   1         return revale;
 244   1      }
 245          /*********************************************************************************************************
             -**
 246          /*函数：void nRF24L01_TxPacket(unsigned char * tx_buf)
 247          /*功能：发送 tx_buf中数据
 248          /*********************************************************************************************************
             -*/
 249          /*void nRF24L01_TxPacket(unsigned char * tx_buf)
 250          {
 251             CE=0;       //StandBy I模式   
 252             SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // 装载接收端地址
 253             SPI_Write_Buf(WR_TX_PLOAD, tx_buf, TX_PLOAD_WIDTH);          // 装载数据   
 254             SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);         // IRQ收发完成中断响应，16位CRC，主发送
 255             CE=1;     //置高CE，激发数据发送
 256             inerDelay_us(10);
 257          }*/
 258          
 259          
 260           /******************************************************************** 
 261          du1302
 262          ***********************************************************************/
 263          
 264          
 265          
 266          void du_ds1302() 
 267          {
 268   1          uchar k;
 269   1         
 270   1       //   uchar taddr = 0x81;
 271   1        // for (k=0; k<3; k++)
 272   1       //   {
 273   1        //      now_time[k] = read_data_ds1302(taddr);/*格式为: 秒 分 时 日 月 星期 年 */
 274   1        //      taddr+= 2;
 275   1       //   }
 276   1      
 277   1         k= read_data_ds1302(0x81);
 278   1         k=bcd16(k);
 279   1         if(k<60) sec=k;
 280   1         if(k>=60)
 281   1         {
 282   2            k= read_data_ds1302(0x81);
 283   2            k=bcd16(k);
 284   2            if(k<60) sec=k;
 285   2            if(k>=60)
 286   2            {
 287   3               k= read_data_ds1302(0x81);
 288   3               k=bcd16(k);
 289   3               if(k<60) sec=k;
 290   3               if(k>=60)
 291   3               {
 292   4                  write_data_ds1302(0x80,hexbcd(0)); //向DS1302内写秒寄存器80H写入初始秒数据00
 293   4                  write_data_ds1302(0x82,hexbcd(0));//向DS1302内写分寄存器82H写入初始分数据00
 294   4                  write_data_ds1302(0x84,hexbcd(8));//向DS1302内写小时寄存器84H写入初始小时数据12
 295   4                  write_data_ds1302(0x86,hexbcd(11));//向DS1302内写日期寄存器86H写入初始日期数据07
 296   4                  write_data_ds1302(0x88,hexbcd(2));//向DS1302内写月份寄存器88H写入初始月份数据01
 297   4                  write_data_ds1302(0x8c,hexbcd(17));//向DS1302内写年份寄存器8cH写入初始年份数据10
 298   4                  write_data_ds1302(0x8e,0x80); 
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 6   

 299   4                  date=11;month=2;year=17;
 300   4               }
 301   3            }
 302   2         }
 303   1         
 304   1         k= read_data_ds1302(0x83);
 305   1         k=bcd16(k);
 306   1         //if(k<60)
 307   1            min=k;
 308   1         
 309   1         k=read_data_ds1302(0x85);
 310   1         k=bcd16(k);
 311   1         //if(k<24)
 312   1            hor=k;
 313   1         
 314   1         k=read_data_ds1302(0x87);
 315   1         k=bcd16(k);
 316   1         //if(k<24)
 317   1            date=k;
 318   1         k=read_data_ds1302(0x89);
 319   1         k=bcd16(k);
 320   1         //if(k<24)
 321   1            month=k;
 322   1         k=read_data_ds1302(0x8d);
 323   1         k=bcd16(k);
 324   1         //if(k<24)
 325   1            year=k;
 326   1      }
 327          
 328          void xianshishijian(void)
 329          {
 330   1         LCD_Setaddress(1,1);
 331   1      
 332   1         print("时间");
 333   1         LCD_write_dat(':');
 334   1         LCD_write_dat(hor/10+0x30);  
 335   1         LCD_write_dat(hor%10+0x30); 
 336   1         LCD_write_dat(':'); 
 337   1         LCD_write_dat(min/10+0x30);  
 338   1         LCD_write_dat(min%10+0x30); 
 339   1         LCD_write_dat(':');
 340   1         LCD_write_dat(sec/10+0x30);  
 341   1         LCD_write_dat(sec%10+0x30);
 342   1         LCD_write_dat(' ');
 343   1         LCD_write_dat(' ');
 344   1         LCD_write_dat(' ');
 345   1      }
 346          
 347          
 348          void xianshiwsd(void)//显示温湿度
 349          
 350          {
 351   1      
 352   1          LCD_Setaddress(2,1);
 353   1          //if(wendu>=99)wendu=99;
 354   1          print("温度");
 355   1          LCD_write_dat(':');
 356   1          LCD_write_dat(wendu/10+0x30);  
 357   1          LCD_write_dat(wendu%10+0x30); 
 358   1          LCD_write_dat(' ');
 359   1          print("湿度");
 360   1          LCD_write_dat(':');
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 7   

 361   1          LCD_write_dat(shidu/10+0x30);  
 362   1          LCD_write_dat(shidu%10+0x30);
 363   1         LCD_write_dat(' ');
 364   1      }
 365          
 366          
 367          void xianshiguangzhao(void)
 368          {
 369   1         LCD_Setaddress(4,1);
 370   1         print("光照");
 371   1         LCD_write_dat(':');
 372   1         LCD_write_dat(guangzhao/10000+0x30); 
 373   1         LCD_write_dat(guangzhao%10000/1000+0x30);  
 374   1         LCD_write_dat(guangzhao%1000/100+0x30); 
 375   1         LCD_write_dat(guangzhao%100/10+0x30); 
 376   1         LCD_write_dat(guangzhao%10+0x30); 
 377   1         LCD_write_dat(' ');
 378   1         LCD_write_dat('L');
 379   1         LCD_write_dat('x');
 380   1         LCD_write_dat(' ');
 381   1         LCD_write_dat(' ');
 382   1         LCD_write_dat(' ');
 383   1      }
 384          
 385          
 386          void xianshipm(void)
 387          {
 388   1         LCD_Setaddress(3,1);
 389   1      
 390   1         print("PM2.5");
 391   1         LCD_write_dat(':');
 392   1         LCD_write_dat(pm25/100+0x30); 
 393   1         LCD_write_dat(pm25%100/10+0x30);  
 394   1         LCD_write_dat(pm25%10+0x30); 
 395   1         LCD_write_dat('u');
 396   1         LCD_write_dat('g');
 397   1         LCD_write_dat('/');
 398   1         LCD_write_dat('m');
 399   1         LCD_write_dat('3');
 400   1         LCD_write_dat(' ');
 401   1         LCD_write_dat(' ');
 402   1      }
 403          
 404          void ShowSetTime(void)
 405          {
 406   1         LCD_clr();
 407   1         LCD_Setaddress(1,2);
 408   1         print("设置日期时间");
 409   1         LCD_Setaddress(3,1);
 410   1         print("日期");
 411   1         LCD_write_dat(':');
 412   1         LCD_write_dat(' ');
 413   1         LCD_write_dat(year/10+0x30);  
 414   1         LCD_write_dat(year%10+0x30); 
 415   1         LCD_write_dat('-'); 
 416   1         LCD_write_dat(month/10+0x30);  
 417   1         LCD_write_dat(month%10+0x30); 
 418   1         LCD_write_dat('-');
 419   1         LCD_write_dat(date/10+0x30);  
 420   1         LCD_write_dat(date%10+0x30);
 421   1         LCD_write_dat(' ');
 422   1         LCD_write_dat(' ');
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 8   

 423   1         
 424   1         LCD_Setaddress(4,1);
 425   1         print("时间");
 426   1         LCD_write_dat(':');
 427   1         LCD_write_dat(' ');
 428   1         LCD_write_dat(hor/10+0x30);  
 429   1         LCD_write_dat(hor%10+0x30); 
 430   1         LCD_write_dat(':'); 
 431   1         LCD_write_dat(min/10+0x30);  
 432   1         LCD_write_dat(min%10+0x30); 
 433   1         LCD_write_dat(':');
 434   1         LCD_write_dat(sec/10+0x30);  
 435   1         LCD_write_dat(sec%10+0x30);
 436   1         LCD_write_dat(' ');
 437   1         LCD_write_dat(' ');
 438   1      }
 439          
 440          void ShowSetAlarmDat(void)
 441          {
 442   1         LCD_clr();
 443   1         LCD_Setaddress(1,2);
 444   1         print("设置上下限值");
 445   1         LCD_Setaddress(2,1);
 446   1         print("PM2.5");
 447   1         LCD_write_dat(':');
 448   1         LCD_write_dat(Alpm25/100+0x30); 
 449   1         LCD_write_dat(Alpm25%100/10+0x30);  
 450   1         LCD_write_dat(Alpm25%10+0x30); 
 451   1         LCD_write_dat('u');
 452   1         LCD_write_dat('g');
 453   1         LCD_write_dat('/');
 454   1         LCD_write_dat('m');
 455   1         LCD_write_dat('3');
 456   1         
 457   1         LCD_Setaddress(3,1);
 458   1         print("温度");
 459   1         LCD_write_dat(':');
 460   1         LCD_write_dat(' ');
 461   1         LCD_write_dat('H');
 462   1         LCD_write_dat('=');
 463   1         LCD_write_dat(stwdh/10+0x30);  
 464   1         LCD_write_dat(stwdh%10+0x30); 
 465   1         LCD_write_dat(' ');
 466   1         LCD_write_dat('L');
 467   1         LCD_write_dat('=');
 468   1         LCD_write_dat(stwdl/10+0x30);  
 469   1         LCD_write_dat(stwdl%10+0x30); 
 470   1         LCD_write_dat(' ');
 471   1         
 472   1         LCD_Setaddress(4,1);
 473   1         print("湿度");
 474   1         LCD_write_dat(':');
 475   1         LCD_write_dat(' ');
 476   1         LCD_write_dat('H');
 477   1         LCD_write_dat('=');
 478   1         LCD_write_dat(stsdh/10+0x30);  
 479   1         LCD_write_dat(stsdh%10+0x30); 
 480   1         LCD_write_dat(' ');
 481   1         LCD_write_dat('L');
 482   1         LCD_write_dat('=');
 483   1         LCD_write_dat(stsdl/10+0x30);  
 484   1         LCD_write_dat(stsdl%10+0x30); 
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 9   

 485   1         LCD_write_dat(' ');
 486   1      }
 487          
 488          
 489          void SetFun(void)
 490          {
 491   1         unsigned int i=2000;
 492   1         if((k1==0)||(k2==0))
 493   1         {
 494   2            Delay(5000) ;
 495   2            if((k1==0)&&(k2==0))
 496   2            {
 497   3               write_data_ds1302(0x8e,0x00);
 498   3               write_data_ds1302(0x80,hexbcd(0)); //向DS1302内写秒寄存器80H写入初始秒数据00
 499   3               write_data_ds1302(0x82,hexbcd(0));//向DS1302内写分寄存器82H写入初始分数据00
 500   3               write_data_ds1302(0x84,hexbcd(8));//向DS1302内写小时寄存器84H写入初始小时数据12
 501   3               write_data_ds1302(0x86,hexbcd(11));//向DS1302内写日期寄存器86H写入初始日期数据07
 502   3               write_data_ds1302(0x88,hexbcd(2));//向DS1302内写月份寄存器88H写入初始月份数据01
 503   3               write_data_ds1302(0x8c,hexbcd(17));//向DS1302内写年份寄存器8cH写入初始年份数据10
 504   3               write_data_ds1302(0x8e,0x80); 
 505   3               date=11;month=2;year=17;
 506   3               SetB=0;SetA=0;
 507   3               fmq=0;delay_ms(50);fmq=1;delay_ms(300);
 508   3               fmq=0;delay_ms(50);fmq=1;
 509   3            }
 510   2            while((k1==0)&&(k2==0));
 511   2            
 512   2         }
 513   1         if(k1==0)
 514   1         {
 515   2            Delay(5000) ;
 516   2            
 517   2            if(k1==0)
 518   2            {
 519   3               SetB=0;
 520   3               if(SetA<6) SetA++;
 521   3               else SetA=0;
 522   3               switch(SetA)
 523   3               {
 524   4                  case 0:  LCD_clr();break;
 525   4                  case 1:  
 526   4                  case 2:  
 527   4                  case 3:  
 528   4                  case 4:  
 529   4                  case 5:  
 530   4                  case 6:  ShowSetTime();break;          
 531   4               }
 532   3            }
 533   2            while(k1==0);
 534   2         }
 535   1         
 536   1         if(k2==0)
 537   1         {
 538   2            Delay(5000) ;
 539   2            
 540   2            if(k2==0)
 541   2            {
 542   3               SetA=0;
 543   3               if(SetB<5) SetB++;
 544   3               else SetB=0;
 545   3               switch(SetB)
 546   3               {
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 10  

 547   4                  case 0:  LCD_draw_clr();break;
 548   4                  case 1:  
 549   4                  case 2:  
 550   4                  case 3:  
 551   4                  case 4:  
 552   4                  case 5:  ShowSetAlarmDat();break;            
 553   4               }
 554   3            }
 555   2            while(k2==0);
 556   2         }
 557   1         
 558   1         if(SetA!=0)
 559   1         {
 560   2            if(k3==0)
 561   2            {
 562   3               Delay(5000) ;
 563   3               if(k3==0)
 564   3               {
 565   4                  switch(SetA)
 566   4                  {
 567   5                     case 1:  sec++;if(sec>59) sec=0;break;
 568   5                     case 2:  min++;if(min>59) min=0;break;
 569   5                     case 3:  hor++;if(hor>23) hor=0;break;
 570   5                     case 4:  
 571   5                     {
 572   6                        if((month==1)||(month==3)||(month==5)||(month==7)||(month==8)||(month==10)||(month==12)) 
 573   6                        {
 574   7                           date++; 
 575   7                           if(date>31) date=1;
 576   7                        }
 577   6                        else if((month==4)||(month==6)||(month==9)||(month==11))
 578   6                        {
 579   7                           date++; 
 580   7                           if(date>30) date=1;
 581   7                        }
 582   6                        else if(month==2)
 583   6                        {
 584   7                           i=2000+year;
 585   7                           if((i%100)==0)
 586   7                           {
 587   8                              if(i%400==0)   {date++; if(date>29) date=1;}
 588   8                              else {date++; if(date>28) date=1;}
 589   8                           }
 590   7                           else
 591   7                           {
 592   8                              if((i%4)==0)   {date++; if(date>29) date=1;}
 593   8                              else {date++; if(date>28) date=1;}
 594   8                           }
 595   7                        }
 596   6                        else {date++; if(date>31) date=1;}
 597   6                     }break;
 598   5                     case 5:  
 599   5                     {
 600   6                        month++;if(month>12) month=1;
 601   6                        if(date>28)
 602   6                        {
 603   7                           if(month==2)
 604   7                           {
 605   8                              i=2000+year;
 606   8                              if((i%100)==0)
 607   8                              {
 608   9                                 if((i%400)==0) date=29;
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 11  

 609   9                                 else date=28;
 610   9                              }
 611   8                              else
 612   8                              {
 613   9                                 if((i%4)==0)    date=29;
 614   9                                 else date=28;
 615   9                              }
 616   8                           }
 617   7                           if((month==4)||(month==6)||(month==9)||(month==11))
 618   7                           {
 619   8                              if(date>30) date=1;
 620   8                           }
 621   7                        }
 622   6                     }break;
 623   5                     case 6:  
 624   5                     {
 625   6                        year++;if(year>99) year=1;
 626   6                        if(date>28)
 627   6                        {
 628   7                           if(month==2)
 629   7                           {
 630   8                              i=2000+year;
 631   8                              if((i%100)==0)
 632   8                              {
 633   9                                 if((i%400)==0) date=29;
 634   9                                 else date=28;
 635   9                              }
 636   8                              else
 637   8                              {
 638   9                                 if((i%4)==0)    date=29;
 639   9                                 else date=28;
 640   9                              }
 641   8                           }
 642   7                           if((month==4)||(month==6)||(month==9)||(month==11))
 643   7                           {
 644   8                              if(date>30) date=1;
 645   8                           }
 646   7                        }
 647   6                     }break;
 648   5                  }
 649   4               }
 650   3            }
 651   2            if(k4==0)
 652   2            {
 653   3               Delay(5000) ;
 654   3               if(k4==0)
 655   3               {
 656   4                  switch(SetA)
 657   4                  {
 658   5                     case 1:  if(sec>0) sec--; break;
 659   5                     case 2:  if(min>0) min--; break;
 660   5                     case 3:  if(hor>0) hor--; break;
 661   5                     case 4:  if(date>1) date--; break;
 662   5                     case 5:  
 663   5                     {
 664   6                        if(month>1) month--; 
 665   6                        if(date>28)
 666   6                        {
 667   7                           if(month==2)
 668   7                           {
 669   8                              i=2000+year;
 670   8                              if((i%100)==0)
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 12  

 671   8                              {
 672   9                                 if((i%400)==0) date=29;
 673   9                                 else date=28;
 674   9                              }
 675   8                              else
 676   8                              {
 677   9                                 if((i%4)==0)    date=29;
 678   9                                 else date=28;
 679   9                              }
 680   8                           }
 681   7                           if((month==4)||(month==6)||(month==9)||(month==11))
 682   7                           {
 683   8                              if(date>30) date=1;
 684   8                           }
 685   7                        }
 686   6                     }break;
 687   5                     case 6:  
 688   5                     {
 689   6                        if(year>1) year--; 
 690   6                        if(date>28)
 691   6                        {
 692   7                           if(month==2)
 693   7                           {
 694   8                              i=2000+year;
 695   8                              if((i%100)==0)
 696   8                              {
 697   9                                 if((i%400)==0) date=29;
 698   9                                 else date=28;
 699   9                              }
 700   8                              else
 701   8                              {
 702   9                                 if((i%4)==0)    date=29;
 703   9                                 else date=28;
 704   9                              }
 705   8                           }
 706   7                           if((month==4)||(month==6)||(month==9)||(month==11))
 707   7                           {
 708   8                              if(date>30) date=1;
 709   8                           }
 710   7                        }
 711   6                     }break;
 712   5                  }
 713   4               }
 714   3            }
 715   2            switch(SetA)
 716   2            {
 717   3               case 1:
 718   3               {
 719   4                  write_data_ds1302(0x8e,0x00); 
 720   4                  write_data_ds1302(0x80, hexbcd(sec));
 721   4                  write_data_ds1302(0x8e,0x80); 
 722   4                  LCD_Setaddress(4,7);
 723   4                  LCD_write_dat(' ');  
 724   4                  LCD_write_dat(' ');
 725   4                  delay_ms(20);
 726   4                  LCD_Setaddress(4,7);
 727   4                  LCD_write_dat(sec/10+0x30);  
 728   4                  LCD_write_dat(sec%10+0x30);
 729   4                  LCD_write_dat(' ');
 730   4                  LCD_write_dat(' ');                 
 731   4               }break;
 732   3               case 2:
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 13  

 733   3               {
 734   4                  write_data_ds1302(0x8e,0x00); 
 735   4                  write_data_ds1302(0x82, hexbcd(min));
 736   4                  write_data_ds1302(0x8e,0x80); 
 737   4                  LCD_Setaddress(4,5);
 738   4                  LCD_write_dat(':');
 739   4                  LCD_write_dat(' ');  
 740   4                  LCD_write_dat(' '); 
 741   4                  delay_ms(10);
 742   4                  LCD_Setaddress(4,5);
 743   4                  LCD_write_dat(':');
 744   4                  LCD_write_dat(min/10+0x30);  
 745   4                  LCD_write_dat(min%10+0x30);
 746   4                     
 747   4               }break;
 748   3               case 3:
 749   3               {
 750   4                  write_data_ds1302(0x8e,0x00); 
 751   4                  write_data_ds1302(0x84, hexbcd(hor));
 752   4                  write_data_ds1302(0x8e,0x80); 
 753   4                  LCD_Setaddress(4,4);
 754   4                  LCD_write_dat(' ');  
 755   4                  LCD_write_dat(' ');
 756   4                  delay_ms(20);
 757   4                  LCD_Setaddress(4,4);
 758   4                  LCD_write_dat(hor/10+0x30);  
 759   4                  LCD_write_dat(hor%10+0x30);
 760   4                     
 761   4               }break;
 762   3               case 4:
 763   3               {
 764   4                  write_data_ds1302(0x8e,0x00); 
 765   4                  write_data_ds1302(0x86, hexbcd(date));
 766   4                  write_data_ds1302(0x8e,0x80); 
 767   4                  LCD_Setaddress(3,7);
 768   4                  LCD_write_dat(' ');  
 769   4                  LCD_write_dat(' ');
 770   4                  delay_ms(20);
 771   4                  LCD_Setaddress(3,7);
 772   4                  LCD_write_dat(date/10+0x30);  
 773   4                  LCD_write_dat(date%10+0x30);
 774   4                  LCD_write_dat(' ');
 775   4                  LCD_write_dat(' ');                 
 776   4               }break;
 777   3               case 5:
 778   3               {
 779   4                  write_data_ds1302(0x8e,0x00); 
 780   4                  write_data_ds1302(0x88, hexbcd(month));
 781   4                  write_data_ds1302(0x8e,0x80); 
 782   4                  LCD_Setaddress(3,5);
 783   4                  LCD_write_dat('-');
 784   4                  LCD_write_dat(' ');  
 785   4                  LCD_write_dat(' '); 
 786   4                  delay_ms(10);
 787   4                  LCD_Setaddress(3,5);
 788   4                  LCD_write_dat('-');
 789   4                  LCD_write_dat(month/10+0x30);  
 790   4                  LCD_write_dat(month%10+0x30);
 791   4                  if(month==2)
 792   4                  {
 793   5                     write_data_ds1302(0x8e,0x00); 
 794   5                     write_data_ds1302(0x86, hexbcd(date));
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 14  

 795   5                     write_data_ds1302(0x8e,0x80);
 796   5                     LCD_Setaddress(3,7);
 797   5                     LCD_write_dat(date/10+0x30);  
 798   5                     LCD_write_dat(date%10+0x30);  
 799   5                  }
 800   4                     
 801   4               }break;
 802   3               case 6:
 803   3               {
 804   4                  write_data_ds1302(0x8e,0x00); 
 805   4                  write_data_ds1302(0x8c, hexbcd(year));
 806   4                  write_data_ds1302(0x8e,0x80); 
 807   4                  LCD_Setaddress(3,4);
 808   4                  LCD_write_dat(' ');  
 809   4                  LCD_write_dat(' ');
 810   4                  delay_ms(20);
 811   4                  LCD_Setaddress(3,4);
 812   4                  LCD_write_dat(year/10+0x30);  
 813   4                  LCD_write_dat(year%10+0x30);
 814   4                  if(month==2)
 815   4                  {
 816   5                     write_data_ds1302(0x8e,0x00); 
 817   5                     write_data_ds1302(0x86, hexbcd(date));
 818   5                     write_data_ds1302(0x8e,0x80);
 819   5                     LCD_Setaddress(3,7);
 820   5                     LCD_write_dat(date/10+0x30);  
 821   5                     LCD_write_dat(date%10+0x30);  
 822   5                  }
 823   4                     
 824   4               }break;
 825   3            }
 826   2            
 827   2         }
 828   1         
 829   1         /*************************************设置上下限参数*******************************/
 830   1         if(SetB!=0)
 831   1         {
 832   2            if(k3==0)
 833   2            {
 834   3               Delay(5000) ;
 835   3               if(k3==0)
 836   3               {
 837   4                  switch(SetB)
 838   4                  {
 839   5                     case 1:  stsdl++;if(stsdl>90) stsdl=0;break;
 840   5                     case 2:  stsdh++;if(stsdh>90) stsdh=0;break;
 841   5                     case 3:  stwdl++;if(stwdl>60) stwdl=0;break;
 842   5                     case 4:  stwdh++;if(stwdh>60) stwdh=0;break;
 843   5                     case 5:  Alpm25++;if(Alpm25>990) Alpm25=20;break;
 844   5                  }
 845   4               }
 846   3            }
 847   2            if(k4==0)
 848   2            {
 849   3               Delay(5000) ;
 850   3               if(k4==0)
 851   3               {
 852   4                  switch(SetB)
 853   4                  {
 854   5                     case 1:  if(stsdl>0) stsdl--; break;
 855   5                     case 2:  if(stsdh>0) stsdh--; break;
 856   5                     case 3:  if(stwdl>0) stwdl--; break;
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 15  

 857   5                     case 4:  if(stwdh>0) stwdh--; break;
 858   5                     case 5:  if(Alpm25>20) Alpm25--; break;
 859   5                  }
 860   4               }
 861   3            }
 862   2            switch(SetB)
 863   2            {
 864   3               case 1:
 865   3               {
 866   4                  LCD_Setaddress(4,7);
 867   4                  LCD_write_dat('=');  
 868   4                  LCD_write_dat(' ');
 869   4                  LCD_write_dat(' ');
 870   4                  delay_ms(20);
 871   4                  LCD_Setaddress(4,7);
 872   4                  LCD_write_dat('='); 
 873   4                  LCD_write_dat(stsdl/10+0x30);  
 874   4                  LCD_write_dat(stsdl%10+0x30);
 875   4                  LCD_write_dat(' ');
 876   4                  LCD_write_dat(' ');                 
 877   4               }break;
 878   3               case 2:
 879   3               {
 880   4                  LCD_Setaddress(4,5);
 881   4                  LCD_write_dat(' ');  
 882   4                  LCD_write_dat(' '); 
 883   4                  delay_ms(20);
 884   4                  LCD_Setaddress(4,5);
 885   4                  LCD_write_dat(stsdh/10+0x30);  
 886   4                  LCD_write_dat(stsdh%10+0x30);
 887   4                     
 888   4               }break;
 889   3               case 3:
 890   3               {  
 891   4                  LCD_Setaddress(3,7);
 892   4                  LCD_write_dat('=');  
 893   4                  LCD_write_dat(' ');
 894   4                  LCD_write_dat(' ');
 895   4                  delay_ms(20);
 896   4                  LCD_Setaddress(3,7);
 897   4                  LCD_write_dat('='); 
 898   4                  LCD_write_dat(stwdl/10+0x30);  
 899   4                  LCD_write_dat(stwdl%10+0x30);
 900   4                  LCD_write_dat(' ');
 901   4                  LCD_write_dat(' ');        
 902   4                     
 903   4               }break;
 904   3               case 4:
 905   3               {
 906   4                  LCD_Setaddress(3,5);
 907   4                  LCD_write_dat(' ');  
 908   4                  LCD_write_dat(' '); 
 909   4                  delay_ms(20);
 910   4                  LCD_Setaddress(3,5);
 911   4                  LCD_write_dat(stwdh/10+0x30);  
 912   4                  LCD_write_dat(stwdh%10+0x30);          
 913   4               }break;
 914   3               case 5:
 915   3               {
 916   4                  LCD_Setaddress(2,4);
 917   4                  LCD_write_dat(' ');
 918   4                  LCD_write_dat(' ');  
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 16  

 919   4                  LCD_write_dat(' '); 
 920   4                  delay_ms(20);
 921   4                  LCD_Setaddress(2,4); 
 922   4                  LCD_write_dat(Alpm25/100+0x30); 
 923   4                  LCD_write_dat(Alpm25%100/10+0x30);  
 924   4                  LCD_write_dat(Alpm25%10+0x30); 
 925   4               }break;
 926   3            }
 927   2            
 928   2         }
 929   1         
 930   1         
 931   1         
 932   1         if(k5==0)
 933   1         {
 934   2            Delay(5000) ;
 935   2            
 936   2            if(k5==0)
 937   2            {
 938   3               SetB=0;SetA=0;
 939   3               LCD_clr();
 940   3            }  
 941   2         }  
 942   1         
 943   1         
 944   1      }
 945          
 946          
 947          //************************************主函数************************************************************
 948          void main(void)
 949          {  
 950   1         init_ds1302();
 951   1         LCD_init();
 952   1         LCD_draw_clr();
 953   1         
 954   1         init_NRF24L01() ;
 955   1         delay_ms(1);
 956   1         Delay(6000);
 957   1         
 958   1         k1=1;
 959   1         k2=1;
 960   1         k3=1;
 961   1         k4=1;
 962   1         while(1)
 963   1         {
 964   2            if((SetA==0)&&(SetB==0))
 965   2            {
 966   3               flag++;
 967   3               du_ds1302() ;           //读取1302时间
 968   3               xianshishijian();        //显示时间     
 969   3               SetRX_Mode();           //设置2401 接收模式
 970   3               if(nRF24L01_RxPacket(RxBuf))  //读取2401 接收寄存器
 971   3               {
 972   4                  if(RxBuf[1]==0xaa)                                //数据处理 
 973   4                  {
 974   5                     wendu=RxBuf[3];    
 975   5                                      
 976   5                     shidu=RxBuf[5];   
 977   5                     guangzhao=RxBuf[7]*10000+ RxBuf[8]*1000 +RxBuf[9]*100+RxBuf[10]*10+RxBuf[11];
 978   5      
 979   5                     pm25= RxBuf[12]*100+RxBuf[13];
 980   5                  }
C51 COMPILER V9.55   RX                                                                    02/13/2017 08:37:25 PAGE 17  

 981   4                  xianshiwsd();
 982   4                  xianshipm();
 983   4                  xianshiguangzhao();
 984   4                  flag=0;
 985   4               }  
 986   3      
 987   3               /////以下为设置 上下限报警程序
 988   3               if((pm25<995)&&(pm25>0))
 989   3               {
 990   4                  if((wendu>stwdh )||(wendu<stwdl)||(shidu>stsdh)||(shidu<stsdl)||(pm25>Alpm25) )  fmq=0;
 991   4                  else    fmq=1;
 992   4               }
 993   3      
 994   3               if(flag>=250)                  //超过250未连接 显示通讯连接
 995   3               {
 996   4                  LCD_draw_clr();
 997   4                  LCD_Setaddress(2,1);
 998   4      
 999   4                  print("通讯连接中。。。");
1000   4                  flag=0;
1001   4               }
1002   3            }
1003   2            SetFun();   //设置参数
1004   2         }  
1005   1      }
1006          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4278    ----
   CONSTANT SIZE    =     97    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34      15
   IDATA SIZE       =     34    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
